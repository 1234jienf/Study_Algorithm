## 1 <= N <= 100,000
# ## 외치는 정수는 -10,000보다 크거나 같고, 10,000 보다 작거나 같다

## input
# 7 - 정수 N
# 1
# 5
# 2
# 10
# -99
# 7
# 5

## output
# 1 (1)
# 1 (1,5)
# 2 (1,2,5)
# 2 (1,2,5,10)
# 2 (-99,1,2,5,10)
# 2 (-99,1,2,5,7,10)
# 5 (-99,1,2,5,5,7,10)


## 두가지 힙을 두어서 중앙값을 기준으로 그룹을 나누고,
## 중앙값보다 작은 숫자를 넣은 그룹과 중앙값보다 큰 숫자를 넣은 그룹
## 중 중앙값은 항상 작은 숫자 그룹의 마지막 수

## 1 -> [1] - 작은 숫자 그룹 -> 중앙값 1 (작은 숫자 그룹 큰 수)
## 5 -> 5 > 1 따라서, [5] - 큰 숫자 그룹 -> 중앙값 1(작은 숫자 그룹 큰 수)
## 2 -> 2 > 1 따라서, [2,5] - 큰 숫자 그룹 -> 중앙값 2 (큰 숫자 그룹 작은 수)
## 큰 숫자 그룹 > 작은 숫자 그룹 -> 큰 숫자 그룹의 가장 작은 수를 작은 숫자 그룹 숫자 넣어주면 됨

## [1,2] , [5] -> 2가 중앙값  (1,2,5)
## 10 -> 10 > 2 따라서, [2,5,10] - 큰 숫자 그룹 -> 중앙값 2 (큰 숫자 그룹 작은 수)
## -99 -> -99 < 2 따라서, [-99, 1] - 작은 숫자 그룹. [2,5,10] -> 중앙값 2 (큰 숫자 그룹 작은 수)
## 7 -> 7 > 2 따라서, [-99,1] , [2,5,7,10] -> 중앙값 2
## 5 -> 5 > 2 따라서, [-99,1] , [2,5,5,7,10] -> 중앙값

## 이런 문제로 인해서 작은 숫자 그룹과 큰 숫자 그룹의 갯수 차가 1은 있어야한다.

import heapq
import sys


input = sys.stdin.read

data = list(map(int, input().split()))
N = data[0]
## 작은 그룹 숫자 (음수 저장)
small_heap = []
## 큰 그룹 숫자 (최소 힙)
heap = []

for i in range(1, N + 1):
  num = data[i]


  ## 첫번째 숫자는 작은 그룹 숫자에 넣기 / 중앙값과 숫자 비교해서 작거나 같으면 넣기
  if not small_heap or num <= -small_heap[0]:
    heapq.heappush(small_heap, -num)  ## 음수로 저장 (-1)
  else:
    heapq.heappush(heap, num) 
  
  ## 크기 조정
  if len(small_heap) > len(heap) + 1:
    heapq.heappush(heap, -heapq.heappop(small_heap))
  elif len(heap) > len(small_heap):
    heapq.heappush(small_heap, -heapq.heappop(heap))

  print(-small_heap[0])